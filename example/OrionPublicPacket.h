// OrionPublicPacket.h was generated by ProtoGen version 2.12.c

#ifndef _ORIONPUBLICPACKET_H
#define _ORIONPUBLICPACKET_H

// C++ compilers: don't mangle us
#ifdef __cplusplus
extern "C" {
#endif

/*!
 * \file
 */

#include "OrionPublicProtocol.h"
#include "GpsDataReceive.h"	// For postUpdate() functions
#include "mathutilities.h"	// For computeDateAndTimeFromWeekAndItow() function

/*!
 * Compresssed date format.
 */
typedef struct
{
    unsigned year : 7;  //!< Years after 2000
    unsigned month : 4; //!< Month of the year, from 1 to 12
    unsigned day : 5;   //!< Day of the month, from 1 to 31
}Date_t;

//! return the minimum encoded length for the Date_t structure
#define getMinLengthOfDate_t() (2)

//! Encode a Date_t structure into a byte array
void encodeDate_t(uint8_t* data, int* bytecount, const Date_t* user);

//! Decode a Date_t structure from a byte array
int decodeDate_t(const uint8_t* data, int* bytecount, Date_t* user);

/*!
 * Structure for holding a gimbal axis command
 */
typedef struct
{
    float       Target[NUM_GIMBAL_AXES]; //!< Pan and tilt commands in radians or radians per second. Interpretation depends on Mode.
    OrionMode_t Mode;                    //!< Operational mode of the gimbal. Note that not all modes can be directly commanded.
    uint8_t     Stabilized;              //!< Non-zero to enable inertial stabilization. If zero then Target is with respect to the gimbal mount, otherwise Target is with respect to the inertial or image space.
    float       ImpulseTime;             //!< Amount of time in seconds for changing the gimbal position
}OrionCmd_t;

//! return the minimum encoded length for the OrionCmd_t structure
#define getMinLengthOfOrionCmd_t() (2*NUM_GIMBAL_AXES+3)

//! Encode a OrionCmd_t structure into a byte array
void encodeOrionCmd_t(uint8_t* data, int* bytecount, const OrionCmd_t* user);

//! Decode a OrionCmd_t structure from a byte array
int decodeOrionCmd_t(const uint8_t* data, int* bytecount, OrionCmd_t* user);

/*!
 * Per-laser state information.
 */
typedef struct
{
    OrionLaserType_t Type;                //!< The type of this laser
    unsigned         Enabled : 1;         //!< Set to 1 if the laser is enabled, otherwise 0
    unsigned         Armed : 1;           //!< Set to 1 if the laser is armed, otherwise 0
    unsigned         Active : 1;          //!< Set to 1 if the laser is active, otherwise 0
    unsigned         GroundSpeedLock : 1; //!< Set to 1 if the laser is locked due to low ground speed, otherwise 0
    unsigned         AltitudeLock : 1;    //!< Set to 1 if the laser is locked due to low GPS altitude, otherwise 0
    unsigned         PasswordLock : 1;    //!< Set to 1 if the laser is locked by password, otherwise 0
    unsigned         ApCommLock : 1;      //!< Set to 1 if the laser is locked due to lost autopilot comms, otherwise 0
    unsigned         ApFlyingLock : 1;    //!< Set to 1 if the laser is locked because the autopilot is not in a 'flying' state, otherwise 0
    unsigned         BypassEnabled : 1;   //!< Set to 1 if the current command is bypassing the safety interlocks, otherwise 0
    unsigned         PitchAngleLock : 1;  //!< Set to 1 if the laser is locked due to a positive pitch angle, otherwise 0
    unsigned         Reserved : 14;       //!< Reserved for future use. Field is encoded constant.
    uint16_t         WaitTimer;           //!< Time remaining, in milliseconds, before the laser will accept another command
}OrionLaserState_t;

//! return the minimum encoded length for the OrionLaserState_t structure
#define getMinLengthOfOrionLaserState_t() (6)

//! Encode a OrionLaserState_t structure into a byte array
void encodeOrionLaserState_t(uint8_t* data, int* bytecount, const OrionLaserState_t* user);

//! Decode a OrionLaserState_t structure from a byte array
int decodeOrionLaserState_t(const uint8_t* data, int* bytecount, OrionLaserState_t* user);

/*!
 * Enumeration INS rotation options
 */
typedef enum
{
    insInGimbalNative,//!< The INS is running in the gimbal native axis
    insInPlatform,   //!< The INS is running in the platform axis, see the INS options for specific roataion details
    insInPayloadBall //!< The INS is running in the payload ball.
} InsRotationOptions;

/*!
 * This packet is transmitted at 10 Hz by the gimbal to communicate the
 * information needed to locate the gimbal and its imagery, to determine the
 * gimbal mode of operation, and to determine how the video output stream is
 * being shifted by the gimbal. This is the primary packet that users should
 * monitor to determine the gimbal status and populate user interfaces.
 */
typedef struct
{
    uint32_t           systemTime;                    //!< Milliseconds since system bootup
    uint32_t           gpsITOW;                       //!< GPS time of week in milliseconds
    uint16_t           gpsWeek;                       //!< GPS week number since Jan 6 1980
    double             geoidUndulation;               //!< Height of the geoid with respect to the WGS84 ellipsoid, in meters
    double             posLat;                        //!< Geodetic latitude of the gimbal in radians, positive North
    double             posLon;                        //!< Longitude of the gimbal in radians, positive East
    double             posAlt;                        //!< Altitude of the gimbal in meters above the WGS-84 ellipsoid
    float              velNED[3];                     //!< Velocity of the gimbal in North, East, Down meters per second
    float              gimbalQuat[4];                 //!< Gimbal quaternion describing the rotation from the gimbal mount frame to the North, East, Down navigation frame
    float              pan;                           //!< Gimbal pan angle in radians from -pi to pi. This includes the camera alignment offsets.
    float              tilt;                          //!< Gimbal tilt angle in radians from -pi to pi This includes the camera alignment offsets.
    float              hfov;                          //!< Horizontal field of view of the camera in radians from 0 to 2pi
    float              vfov;                          //!< Vertical field of view of the camera in radians from 0 to 2pi
    float              losECEF[3];                    //!< Vector from the gimbal to the image location in ECEF meters. The image location is only computed if ranging data are provided to the gimbal. Otherwise the image location data are 0,0,0
    uint16_t           pixelWidth;                    //!< Active focal plane width in pixels
    uint16_t           pixelHeight;                   //!< Active focal plane height in pixels
    OrionMode_t        mode;                          //!< Operational mode of the gimbal.
    float              pathProgress;                  //!< Distance along the path from 0 (the starting point) to 1 (the ending point). This only applies if the mode is ORION_MODE_PATH.
    float              stareTime;                     //!< Seconds remaining in the stare portion of a step stare point, 0 if stare is not in progress. This only applies if the mode is ORION_MODE_PATH.
    uint8_t            pathFrom;                      //!< Index of the path point gimbal is traveling from. This only applies if the mode is ORION_MODE_PATH.
    uint8_t            pathTo;                        //!< Index of the path point gimbal is traveling to. This only applies if the mode is ORION_MODE_PATH.
    float              imageShifts[NUM_GIMBAL_AXES];  //!< X (horizontal) and Y (vertical) instantaneous image shifts in radians
    float              imageShiftDeltaTime;           //!< The amount of time in seconds over which these shifts apply. If no new shift data has arrived since this packet was last transmitted then this will be 0
    float              imageShiftConfidence;          //!< Registration solution confidence, from 0 (no confidence) to 1 (full confidence).
    float              outputShifts[NUM_GIMBAL_AXES]; //!< X (horizontal) and Y (vertical) image shifts in radians, as displayed in the video stream
    RangeDataSrc_t     rangeSource;                   //!< Range data source used in line of sight calculation
    uint8_t            leapSeconds;                   //!< Leap seconds to subtract from GPS time to compute UTC time
    float              panAlignment;                  //!< Pan camera alignment offsets in radian. The raw pan angle is given as pan + panAlignment.
    float              tiltAlignment;                 //!< Tilt camera alignment offsets in radian. The raw tilt angle is given as tilt + tiltAlignment.
    InsRotationOptions insRotationOption;             //!< This flag indicates special INS options. If insSpecialOption is 1 the INS is running in the gimbal crown, but is rotated from the gimbal native axis. If insSpecialOption is 2 the INS is running in the ball of the gimbal.
    float              insQuat[4];                    //!< The rotation of the INS from its native frame to the North, East, Down navigation frame. If insSpecialOption is 0 then this rotation is the same as the gimbalQuat
    float              imageRotation;                
}GeolocateTelemetryCore_t;

//! Create the GeolocateTelemetryCore packet
void encodeGeolocateTelemetryCorePacketStructure(void* pkt, const GeolocateTelemetryCore_t* user);

//! Decode the GeolocateTelemetryCore packet
int decodeGeolocateTelemetryCorePacketStructure(const void* pkt, GeolocateTelemetryCore_t* user);

//! return the packet ID for the GeolocateTelemetryCore packet
#define getGeolocateTelemetryCorePacketID() (ORION_PKT_GEOLOCATE_TELEMETRY)

//! return the minimum encoded length for the GeolocateTelemetryCore packet
#define getGeolocateTelemetryCoreMinDataLength() (46)

//! return the maximum encoded length for the GeolocateTelemetryCore packet
#define getGeolocateTelemetryCoreMaxDataLength() (6*NUM_GIMBAL_AXES+79)

/*!
 * Measurements related to stabilization performance. This packet is sent by the
 * gimbal 4 times per second.
 */
typedef struct
{
    float RmsQuad[NUM_GIMBAL_AXES]; //!< Quad rms errors
    float RmsDir[NUM_GIMBAL_AXES];  //!< Dir rms errors
    float RmsVel[NUM_GIMBAL_AXES];  //!< Vel rms errors
    float RmsPos[NUM_GIMBAL_AXES];  //!< Pos rms errors
    float Iout[NUM_GIMBAL_AXES];    //!< Output current
}OrionPerformance_t;

//! Create the OrionPerformance packet
void encodeOrionPerformancePacketStructure(void* pkt, const OrionPerformance_t* user);

//! Decode the OrionPerformance packet
int decodeOrionPerformancePacketStructure(const void* pkt, OrionPerformance_t* user);

//! return the packet ID for the OrionPerformance packet
#define getOrionPerformancePacketID() (ORION_PKT_PERFORMANCE)

//! return the minimum encoded length for the OrionPerformance packet
#define getOrionPerformanceMinDataLength() (10*NUM_GIMBAL_AXES)

//! return the maximum encoded length for the OrionPerformance packet
#define getOrionPerformanceMaxDataLength() (10*NUM_GIMBAL_AXES)

/*!
 * Electrical diagnostic data for the Orion gimbal. This packet is sent by the
 * gimbal every 3 seconds.
 */
typedef struct
{
    float Voltage24;       //!< Voltage of the 24-volt rail
    float Voltage12;       //!< Voltage of the 12-volt rail
    float Voltage3v3;      //!< Voltage of the 3.3-volt rail
    float Current24;       //!< Current in Amps of the 24-volt rail
    float Current12;       //!< Current in Amps of the 12-volt rail
    float Current3v3;      //!< Current in Amps of the 3.3-volt rail
    float CrownTemp;       //!< Temperature of the crown board in degrees Celsius
    float SlaTemp;         //!< Temperature of the SLA-1500 board (if applicable) in degrees Celsius
    float GyroTemp;        //!< Stabilization gyro ADC temperature in degrees Celsius
    float Voltage24Var;    //!< Voltage variance of the 24-volt rail
    float Voltage12Var;    //!< Voltage variance of the 12-volt rail
    float Voltage3v3Var;   //!< Voltage variance of the 3.3-volt rail
    float Current24Var;    //!< Current variance in Amps of the 24-volt rail
    float Current12Var;    //!< Current variance in Amps of the 12-volt rail
    float Current3v3Var;   //!< Current variance in Amps of the 3.3-volt rail
    float PayloadTemp;    
    float PayloadHumidity;
}OrionDiagnostics_t;

//! Create the OrionDiagnostics packet
void encodeOrionDiagnosticsPacketStructure(void* pkt, const OrionDiagnostics_t* user);

//! Decode the OrionDiagnostics packet
int decodeOrionDiagnosticsPacketStructure(const void* pkt, OrionDiagnostics_t* user);

//! return the packet ID for the OrionDiagnostics packet
#define getOrionDiagnosticsPacketID() (ORION_PKT_DIAGNOSTICS)

//! return the minimum encoded length for the OrionDiagnostics packet
#define getOrionDiagnosticsMinDataLength() (28)

//! return the maximum encoded length for the OrionDiagnostics packet
#define getOrionDiagnosticsMaxDataLength() (30)

/*!
 * Per-thread information, in order of priority (highest to lowest)
 */
typedef struct
{
    float    cpuLoad;       //!< CPU utilization of this thread as a percentage
    float    heapLoad;      //!< Heap memory utilization of this thread as a percentage, 0 if no heap is present
    float    stackLoad;     //!< Stack memory utilization of this thread as a percentage, 100 if stack overflow occurs
    float    watchdogLeft;  //!< Worst case amount of watchdog time remaining in this reporting period for this thread, 0 if watchdog has timed out
    uint16_t numIterations; //!< Number of times this thread iterated during the reporting period
    float    worstcase;     //!< Worst case thread run time as a ratio with the average thread run time during the reporting period
}ThreadLoading_t;

/*!
 * Per-Core CPU load information
 */
typedef struct
{
    float           cpuLoad;           //!< CPU utilization as a percentage
    float           heapLoad;          //!< Heap memory utilization as a percentage, 0 if no heap is present
    float           stackLoad;         //!< System stack memory utilization as a percentage, 0 if no system stack is present
    uint8_t         numThreads;        //!< Number of threads in the system, must be at least 1
    ThreadLoading_t ThreadLoading[10]; //!< Per-thread information, in order of priority (highest to lowest)
}CoreLoading_t;

/*!
 * Diagnostic information related to software performance for a specific board
 * in the Orion Gimbal. This packet is sent by the gimbal once per second.
 */
typedef struct
{
    OrionBoardEnumeration_t sourceBoard;    //!< Enumeration defining which board in the gimbal generated this message
    uint8_t                 numCores;       //!< Number of CPU cores that this packet reports for
    CoreLoading_t           CoreLoading[2]; //!< Per-Core CPU load information
}OrionSoftwareDiagnostics_t;

//! Create the OrionSoftwareDiagnostics packet
void encodeOrionSoftwareDiagnosticsPacketStructure(void* pkt, const OrionSoftwareDiagnostics_t* user);

//! Decode the OrionSoftwareDiagnostics packet
int decodeOrionSoftwareDiagnosticsPacketStructure(const void* pkt, OrionSoftwareDiagnostics_t* user);

//! return the packet ID for the OrionSoftwareDiagnostics packet
#define getOrionSoftwareDiagnosticsPacketID() (ORION_PKT_SOFTWARE_DIAGNOSTICS)

//! return the minimum encoded length for the OrionSoftwareDiagnostics packet
#define getOrionSoftwareDiagnosticsMinDataLength() (4)

//! return the maximum encoded length for the OrionSoftwareDiagnostics packet
#define getOrionSoftwareDiagnosticsMaxDataLength() (134)

/*!
 * A series of points containing FFT-derived frequency and magnitude data
 */
typedef struct
{
    float Frequency;       //!< Frequency, in Hertz, of the data point defined by this element
    float Accel[NUM_AXES]; //!< Acceleration magnitude, expressed as a percentage of MaxAccel
    float Gyro[NUM_AXES];  //!< Angular rate magnitude, expressed as a percentage of MaxGyro
}FftData_t;

/*!
 * Platform vibration amplitude and frequency information. This packet is sent
 * by the gimbal once every five seconds.
 */
typedef struct
{
    float     MaxAccel[NUM_AXES]; //!< Maximum acceleration values, in m/s/s
    float     MaxGyro[NUM_AXES];  //!< Maximum angular rate values, in rad/s
    FftData_t FftData[16];        //!< A series of points containing FFT-derived frequency and magnitude data
}OrionVibration_t;

//! Create the OrionVibration packet
void encodeOrionVibrationPacketStructure(void* pkt, const OrionVibration_t* user);

//! Decode the OrionVibration packet
int decodeOrionVibrationPacketStructure(const void* pkt, OrionVibration_t* user);

//! return the packet ID for the OrionVibration packet
#define getOrionVibrationPacketID() (ORION_PKT_VIBRATION)

//! return the minimum encoded length for the OrionVibration packet
#define getOrionVibrationMinDataLength() (4*NUM_AXES+16*(2*NUM_AXES+2))

//! return the maximum encoded length for the OrionVibration packet
#define getOrionVibrationMaxDataLength() (4*NUM_AXES+16*(2*NUM_AXES+2))

/*!
 * Ethernet network diagnostic information
 */
typedef struct
{
    uint16_t Flags;         //!< Ethernet interface configuration flags
    uint32_t RxBytes;       //!< Ethernet bytes received
    uint32_t TxBytes;       //!< Ethernet bytes transmitted
    uint32_t RxPackets;     //!< Ethernet packets received
    uint32_t TxPackets;     //!< Ethernet packets transmitted
    uint16_t RxErrors;      //!< Number of receive errors
    uint16_t TxErrors;      //!< Number of transmit errors
    uint16_t RxDrops;       //!< Number of receive packets dropped by the Ethernet driver
    uint16_t TxDrops;       //!< Number of transmit packets dropped by the Ethernet driver
    uint16_t RxFifoErrors;  //!< Number of receive FIFO errors
    uint16_t TxFifoErrors;  //!< Number of transmit FIFO errors
    uint16_t FrameErrors;   //!< Framing error count
    uint16_t Collisions;    //!< Hardware interface collision count
    uint16_t CarrierErrors; //!< Number of carrier loss events
}NetworkDiagnostics_t;

//! Create the NetworkDiagnostics packet
void encodeNetworkDiagnosticsPacketStructure(void* pkt, const NetworkDiagnostics_t* user);

//! Decode the NetworkDiagnostics packet
int decodeNetworkDiagnosticsPacketStructure(const void* pkt, NetworkDiagnostics_t* user);

//! return the packet ID for the NetworkDiagnostics packet
#define getNetworkDiagnosticsPacketID() (ORION_PKT_NETWORK_DIAGNOSTICS)

//! return the minimum encoded length for the NetworkDiagnostics packet
#define getNetworkDiagnosticsMinDataLength() (36)

//! return the maximum encoded length for the NetworkDiagnostics packet
#define getNetworkDiagnosticsMaxDataLength() (36)

/*!
 * The retraction mechanism state
 */
typedef enum
{
    RETRACT_STATE_DISABLED,  //!< Retract is disabled
    RETRACT_STATE_RETRACTED, //!< Retract is fully retracted
    RETRACT_STATE_RETRACTING,//!< Retract is moving to the retracted position
    RETRACT_STATE_DEPLOYING, //!< Retract is moving to the deployed position
    RETRACT_STATE_DEPLOYED,  //!< Retract is fully deployed
    RETRACT_STATE_FAULT      //!< Retract is experiencing a fault condition
} OrionRetractState_t;

/*!
 * Current gimbal retraction mechanism status. This is sent by the gimbal
 * regularly only if a retract system is installed.
 */
typedef struct
{
    OrionRetractCmd_t   Cmd;   //!< The current command being tracked by the retract mechanism
    OrionRetractState_t State; //!< The retraction mechanism state
    float               Pos;   //!< Current retract position in radians
    uint16_t            Flags; //!< GPIO status information flags
}OrionRetractStatus_t;

//! Create the OrionRetractStatus packet
void encodeOrionRetractStatusPacket(void* pkt, OrionRetractCmd_t Cmd, OrionRetractState_t State, float Pos, uint16_t Flags);

//! Decode the OrionRetractStatus packet
int decodeOrionRetractStatusPacket(const void* pkt, OrionRetractCmd_t* Cmd, OrionRetractState_t* State, float* Pos, uint16_t* Flags);

//! return the packet ID for the OrionRetractStatus packet
#define getOrionRetractStatusPacketID() (ORION_PKT_RETRACT_STATUS)

//! return the minimum encoded length for the OrionRetractStatus packet
#define getOrionRetractStatusMinDataLength() (6)

//! return the maximum encoded length for the OrionRetractStatus packet
#define getOrionRetractStatusMaxDataLength() (6)

/*!
 * This packet is transmitted by the gimbal during step-stare operations to
 * indicate that the gimbal is staring and a step-stare image should be
 * acquired. The position data mark the *desired* location that the gimbal is
 * trying to stare at. The *actual* position can be computed by using the gimbal
 * position, quaternion, and pan and tilt angles to project the camera line of
 * sight until to the terrain model. Once the image has been acquired send a
 * ORION_PKT_STARE_ACK packet to tell the gimbal it can move to the next stare
 * point.
 */
typedef struct
{
    uint32_t       systemTime;                    //!< Milliseconds since system bootup. This value should be echoed in the ORION_PKT_STARE_ACK respone.
    float          maxStareTime;                  //!< Seconds remaining before the stare is finished. Send ORION_PKT_STARE_ACK to terminate the stare early.
    unsigned       alongTrackStare : 1;           //!< If set then this is the start of an along track stare, not a cross track track stare
    unsigned       prevStareTerminatedByTime : 1; //!< If set then the previous stare operation was terminated by timeout rather than an ORION_PKT_STARE_ACK packet
    unsigned       stareStartedByTime : 1;        //!< If set then the stare operation was initiated by timeout rather than by achieving the pan and tilt angles necessary to look at the desired location. In this instance it is possible that the actual stare location is significantly different from the desired stare location
    unsigned       gimbalDataValid : 1;           //!< If set then the gimbal position and attitude data are valid. If not set then only the desired stare position is valid
    unsigned       stareReset : 1;                //!< If set then the stare position had to be reset due to falling behind.
    float          prevStareTime;                 //!< Seconds of time elapsed between the previous stare start and stare end. If this number approaches stareTime the image-acquisition system is in danger of not keeping up.
    float          stareLoad;                     //!< Amount of time spent stepping and staring, as a ratio to the time between stare starts. As the frequency of stare events goes up this number will go towards 1.0, indicating the system has reached maximum utilization.
    double         posLat;                        //!< Geodetic latitude of the desired stare point in radians, positive North
    double         posLon;                        //!< Longitude of the desired stare point in radians, positive East
    double         posAlt;                        //!< Altitude of the desired stare point in meters above the WGS-84 ellipsoid
    double         gimbalPosLat;                  //!< Geodetic latitude of the gimbal in radians, positive North
    double         gimbalPosLon;                  //!< Longitude of the gimbal in radians, positive East
    double         gimbalPosAlt;                  //!< Altitude of the gimbal in meters above the WGS-84 ellipsoid
    float          gimbalQuat[4];                 //!< Gimbal quaternion describing the rotation from the gimbal mount frame to the North, East, Down navigation frame
    float          pan;                           //!< Gimbal pan angle in radians from -pi to pi
    float          tilt;                          //!< Gimbal tilt angle in radians from -pi to pi
    RangeDataSrc_t rangeSource;                   //!< Target range data source
    float          slantRange;                    //!< Slant range to target, if available (see rangeSource)
    float          alongStareAngle;               //!< Angle in radians of the view of the path with respect to the perpendicular ideal view. Positive angles indicate looking ahead, negative are looking behind.
    float          crossStareAngle;               //!< Cross track angle in radians of the stare location, which will be zero if cross stepping is not being used. Negative if staring left of the path.
}StareStart_t;

//! Create the StareStart packet
void encodeStareStartPacketStructure(void* pkt, const StareStart_t* user);

//! Decode the StareStart packet
int decodeStareStartPacketStructure(const void* pkt, StareStart_t* user);

//! return the packet ID for the StareStart packet
#define getStareStartPacketID() (ORION_PKT_STARE_START)

//! return the minimum encoded length for the StareStart packet
#define getStareStartMinDataLength() (20)

//! return the maximum encoded length for the StareStart packet
#define getStareStartMaxDataLength() (52)

/*!
 * Reset information for a processor in the Orion Gimbal. This packet is
 * transmitted by each processor in the gimbal following its bootup
 */
typedef struct
{
    uint32_t                Vector;      //!< Interrupt vector for the last reset
    uint32_t                Address;     //!< Program counter prior to the reset (not yet used)
    OrionBoardEnumeration_t sourceBoard; //!< Enumeration defining which board in the gimbal generated this message
}OrionResetSource_t;

//! Create the OrionResetSource packet
void encodeOrionResetSourcePacket(void* pkt, uint32_t Vector, uint32_t Address, OrionBoardEnumeration_t sourceBoard);

//! Decode the OrionResetSource packet
int decodeOrionResetSourcePacket(const void* pkt, uint32_t* Vector, uint32_t* Address, OrionBoardEnumeration_t* sourceBoard);

//! return the packet ID for the OrionResetSource packet
#define getOrionResetSourcePacketID() (ORION_PKT_RESET_SOURCE)

//! return the minimum encoded length for the OrionResetSource packet
#define getOrionResetSourceMinDataLength() (8)

//! return the maximum encoded length for the OrionResetSource packet
#define getOrionResetSourceMaxDataLength() (9)

/*!
 * Priority level of a debug message
 */
typedef enum
{
    debugLevelLog,   //!< Logging information only, lowest priority
    debugLevelInfo,  //!< Informational message
    debugLevelWarn,  //!< Warning message
    debugLevelError, //!< Describes a recoverable error
    debugLevelFatal  //!< Describes an unrecoverable error, highest priority
} debugPriority;

/*!
 * This packet sends a human readable text string which is typically used for
 * debugging purposes.
 */
typedef struct
{
    OrionBoardEnumeration_t source;           //!< Identifier to determine which board sent the debug packet
    debugPriority           priority;         //!< The importance of the debug message
    uint8_t                 reserved1;       
    uint8_t                 reserved2;       
    char                    description[128]; //!< human readable description of the debug problem
}DebugString_t;

//! Create the DebugString packet
void encodeDebugStringPacketStructure(void* pkt, const DebugString_t* user);

//! Decode the DebugString packet
int decodeDebugStringPacketStructure(const void* pkt, DebugString_t* user);

//! return the packet ID for the DebugString packet
#define getDebugStringPacketID() (ORION_PKT_DEBUG_STRING)

//! return the minimum encoded length for the DebugString packet
#define getDebugStringMinDataLength() (5)

//! return the maximum encoded length for the DebugString packet
#define getDebugStringMaxDataLength() (132)

/*!
 * This packet is used to set and query the values of user-configurable KLV tags
 */
typedef struct
{
    uint8_t Key;        //!< UAS Local Set key
    uint8_t SubKey;     //!< UAS Local Set sub-key, if applicable (e.g., security metadata)
    uint8_t Length;     //!< Data length, in bytes
    uint8_t Value[127]; //!< Variable-length value string
}KlvUserData_t;

//! Create the KlvUserData packet
void encodeKlvUserDataPacket(void* pkt, uint8_t Key, uint8_t SubKey, uint8_t Length, const uint8_t Value[127]);

//! Decode the KlvUserData packet
int decodeKlvUserDataPacket(const void* pkt, uint8_t* Key, uint8_t* SubKey, uint8_t* Length, uint8_t Value[127]);

//! return the packet ID for the KlvUserData packet
#define getKlvUserDataPacketID() (ORION_PKT_KLV_USER_DATA)

//! return the minimum encoded length for the KlvUserData packet
#define getKlvUserDataMinDataLength() (3)

//! return the maximum encoded length for the KlvUserData packet
#define getKlvUserDataMaxDataLength() (130)

/*!
 * Enumeration for source of GPS data.
 */
typedef enum
{
    externalSource,                  //!< External GPS, user supplied data
    ubloxSource,                     //!< uBlox internal GPS
    mavlinkSource,                   //!< Mavlink supplied data
    nmeaSource,                      //!< External GPS, supplied by NMEA input
    novatelSource,                   //!< Novatel dual frequency GPS
    autopilotSource,                 //!< Autopilot host GPS data
    piccoloSource = autopilotSource, //!< Preserved for backward compatibility
    piksiSource,                     //!< Piksi external GPS
    numGpsSources                    //!< Number of possible GPS sources
} gpsSource_t;

/*!
 * Enumeration for types of GPS solutions, derived from uBlox specification.
 */
typedef enum
{
    noFix,           //!< No solution
    deadReckoningOnly,//!< Dead reckoning only
    twoDFix,         //!< Two dimensional solution
    threeDFix,       //!< Three dimensional solution
    gnssDeadReckoning,//!< GNSS and dead reckoning combined
    timeOnly         //!< Time only, no position or velocity
} ubloxFixType_t;

/*!
 * Raw GPS data. This packet is normally sent by the gimbal once per second,
 * unless the gimbal is in INS debug mode, in which case this packet is sent for
 * every GPS report. This packet can also be sent to the gimbal in order to
 * provide GPS information. Sending this packet to the gimbal will override any
 * internal GPS. The ideal rate to send this packet to the gimbal is 4Hz.
 *
 * Note that the position information of this packet is *not* the definitive
 * position of the gimbal. That information comes from the INS in the gimbal and
 * is visible in the GeolocateTelemetryCore packet.
 */
typedef struct
{
    unsigned    multiAntHeadingValid : 1;  //!< Set if the GPS has a multi antenna heading solution
    unsigned    FixType : 4;               //!< uBlox fix type
    uint8_t     FixState;                  //!< uBlox fix state
    uint8_t     TrackedSats;               //!< The number of satellites used in the GPS solution
    float       PDOP;                      //!< Position dilution of precision
    double      Latitude;                  //!< Geodetic latitude in radians, positive North
    double      Longitude;                 //!< Longitude in radians, positive East
    double      Altitude;                  //!< Altitude in meters above the WGS-84 ellipsoid
    float       VelNED[3];                 //!< Velocity in North, East, Down meters per second
    float       Hacc;                      //!< Horizontal accuracy in meters
    float       Vacc;                      //!< Vertical accuracy in meters
    float       SpeedAcc;                  //!< Speed accuracy in meters per second
    float       HeadingAcc;                //!< Course accuracy in radians
    uint32_t    ITOW;                      //!< GPS time of week in milliseconds
    uint16_t    Week;                      //!< GPS week number since Jan 6 1980
    float       GeoidUndulation;           //!< Height of the mean seal level geoid with respect to the WGS-84 ellipsoid, in meters
    gpsSource_t source;                    //!< The source of the GPS data
    unsigned    detailedAccuracyValid : 1; //!< Set if detailed accuracy information (posAccuracy and velAccuracy) are included in this packet
    unsigned    verticalVelocityValid : 1; //!< 0 if vertical velocity data are not valid
    uint8_t     leapSeconds;               //!< Leap seconds to subtract from GPS time to compute UTC time
    float       multiAntHeading;           //!< The heading in radians from the multi antenna solution from -pi to pi
    float       posAccuracy[3];            //!< North, East, Down position accuracy estimate in meters
    float       velAccuracy[3];            //!< North, East, Down velocity accuracy estimate in meters per second
    double      posEcef[3];                //!< Position in ECEF x,y,z meters
    float       velEcef[3];                //!< Velocity in ECEF x,y,z meters per second
    float       posEcefAccuracy[3];        //!< ECEF x,y,z position accuracy estimate in meters
    float       velEcefAccuracy[3];        //!< ECEF x,y,z accuracy estimate in meters per second
    uint16_t    Year;                      //!< Year of the date
    uint8_t     Month;                     //!< Month of the year from 1 to 12
    uint8_t     Day;                       //!< Day of the month from 1 to 31
    uint8_t     Hour;                      //!< Hour of the day from 0 to 23
    uint8_t     Minute;                    //!< Minute of the hour from 0 to 59
    uint8_t     Second;                    //!< Second of the minute from 0 to 59
    uint8_t     TimeValid;                 //!< Nonzero if time information is valid
    float       GroundSpeed;               //!< Ground speed in meters per second
    float       GroundHeading;             //!< Course over ground in radians
    uint8_t     valid3DFix;                //!< Nonzero if position solution is valid and 3D
}GpsData_t;

//! Create the GpsData packet
void encodeGpsDataPacketStructure(void* pkt, const GpsData_t* user);

//! Decode the GpsData packet
int decodeGpsDataPacketStructure(const void* pkt, GpsData_t* user);

//! return the packet ID for the GpsData packet
#define getGpsDataPacketID() (ORION_PKT_GPS_DATA)

//! return the minimum encoded length for the GpsData packet
#define getGpsDataMinDataLength() (55)

//! return the maximum encoded length for the GpsData packet
#define getGpsDataMaxDataLength() (69)

/*!
 * Enumeration for the inertial navigation operational mode
 */
typedef enum
{
    insModeInit1,    //!< Awaiting first IMU measurement
    insModeInit2,    //!< Awaiting IMU stabilization
    insModeAHRS,     //!< Running without GPS inputs
    insModeRunHard,  //!< Running with forced GPS inputs
    insModeRun,      //!< Normal mode of operation
    insModeRunTight  //!< Normal mode of operation with tightly coupled corrections
} insMode_t;

/*!
 * Enumeration for IMU type
 */
typedef enum
{
    imuTypeInternal, //!< Internal Trillium IMU
    imuTypeSensonor, //!< Sensonor IMU
    imuTypeDmu11,    //!< DMU-11 IMU
    imuTypeExternal, //!< Other external IMU
    imuTypeEpson,    //!< Epson IMU
    imuTypeVectorNav,//!< VectorNav IMU
    numImuTypes      //!< Number of known IMU types
} imuType_t;

/*!
 * This packet is transmitted once per second by the gimbal to communicate the
 * quality of the inertial navigation system (INS) data. The INS is responsible
 * for fusing the crown board IMU and GPS to determine the position, velocity,
 * attitude, and IMU errors. The quality of the INS data directly impacts the
 * quality of the data in the GeolocateTelemetryCore packet. This data are only
 * sent once per second as the quality data changes slowly.
 */
typedef struct
{
    uint32_t    systemTime;                   //!< Milliseconds since system bootup
    gpsSource_t gpsSource;                    //!< The source of GPS data
    imuType_t   imuType;                      //!< IMU type
    insMode_t   insMode;                      //!< The operational mode of the INS
    unsigned    hasGyroBias : 1;              //!< 1 if the INS is computing and reporting gyro bias states
    unsigned    hasGravityBias : 1;           //!< 1 if the INS is computing and reporting a gravity bias state
    unsigned    hasAccelBias : 1;             //!< 1 if the INS is computing and reporting accelerometer bias states
    unsigned    hasClockBias : 1;             //!< 1 if the INS is computing and reporting clock bias and drift states
    unsigned    hasPanTiltBias : 1;           //!< 1 if the INS is computing and reporting pan and tilt bias states
    unsigned    posRejected : 1;              //!< 1 if the INS rejected the last position update because the chi-square value was too large.
    unsigned    velRejected : 1;              //!< 1 if the INS rejected the last velocity update because the chi-square value was too large.
    unsigned    hdgRejected : 1;              //!< 1 if the INS rejected the last heading update because the chi-square value was too large.
    float       gpsPeriod;                    //!< Time in seconds between GPS measurements, 0 if no measurement
    float       hdgPeriod;                    //!< Time in seconds between heading measurements, 0 if no measurement
    float       posChiSquare;                 //!< Chi-square statistic of the last position observation
    float       velChiSquare;                 //!< Chi-square statistic of the last velocity observation
    float       hdgChiSquare;                 //!< Chi-square statistic of the last heading observation
    float       attConfidence[3];             //!< Attitude confidence in radians as a body Roll, Pitch, Yaw vector
    float       velConfidence[3];             //!< Velocity confidence in meters per second as a North, East, Down vector
    float       posConfidence[3];             //!< Position confidence in meters as a North, East, Down vector
    float       gyroConfidence[3];            //!< Rate gyro bias confidence in radians per second as a body Roll, Pitch, Yaw vector
    float       accelConfidence[3];           //!< Accelerometer bias confidence in m/s/s as a body X, Y, Z vector
    float       gravityConfidence;            //!< Gravity bias confidence in m/s/s
    float       clockBiasConfidence;          //!< Clock bias confidence (for tightly coupled) in meters
    float       clockDriftConfidence;         //!< Clock drift confience (for tightly coupled) in meters per second
    float       gyroBias[3];                  //!< Rate gyro bias estimate in radians per second as a body Roll, Pitch, Yaw vector
    float       accelBias[3];                 //!< Accelerometer bias estimate in m/s/s as a body X, Y, Z vector
    float       gravityBias;                  //!< Gravity bias estimate in m/s/s
    float       clockBias;                    //!< Clock bias estimate (for tightly coupled) in meters
    float       clockDrift;                   //!< Clock drift estimate (for tightly coupled) in meters per second
    uint8_t     numTightSatPosUpdates;        //!< Number of satellites that contributed to tightly coupled position updates
    uint8_t     numTightSatVelUpdates;        //!< Number of satellites that contributed to tightly coupled velocity updates
    uint8_t     numTightPosUpdates;           //!< Number of signals that contributed to tightly coupled position updates
    uint8_t     numTightVelUpdates;           //!< Number of signals that contributed to tightly coupled velocity updates
    float       panTiltBias[NUM_GIMBAL_AXES]; //!< Pan and tilt boresight biases
    float       panTiltChiSquare;             //!< Pan and tilt chi-square statistic
}InsQuality_t;

//! Create the InsQuality packet
void encodeInsQualityPacketStructure(void* pkt, const InsQuality_t* user);

//! Decode the InsQuality packet
int decodeInsQualityPacketStructure(const void* pkt, InsQuality_t* user);

//! return the packet ID for the InsQuality packet
#define getInsQualityPacketID() (ORION_PKT_INS_QUALITY)

//! return the minimum encoded length for the InsQuality packet
#define getInsQualityMinDataLength() (34)

//! return the maximum encoded length for the InsQuality packet
#define getInsQualityMaxDataLength() (2*NUM_GIMBAL_AXES+75)

//! Create the OrionCmd packet
void encodeOrionCmdPacket(void* pkt, const OrionCmd_t* Cmd);

//! Decode the OrionCmd packet
int decodeOrionCmdPacket(const void* pkt, OrionCmd_t* Cmd);

//! return the packet ID for the OrionCmd packet
#define getOrionCmdPacketID() (ORION_PKT_CMD)

//! return the minimum encoded length for the OrionCmd packet
#define getOrionCmdMinDataLength() (2*NUM_GIMBAL_AXES+3)

//! return the maximum encoded length for the OrionCmd packet
#define getOrionCmdMaxDataLength() (2*NUM_GIMBAL_AXES+3)

/*!
 * Command to run upon motor initialization
 */
typedef struct
{
    OrionCmd_t Cmd; //!< Pan/tilt command. Defaults to position mode, pan/tilt of 0
}OrionStartupCmd_t;

//! Create the OrionStartupCmd packet
void encodeOrionStartupCmdPacketStructure(void* pkt, const OrionStartupCmd_t* user);

//! Decode the OrionStartupCmd packet
int decodeOrionStartupCmdPacketStructure(const void* pkt, OrionStartupCmd_t* user);

//! Create the OrionStartupCmd packet
void encodeOrionStartupCmdPacket(void* pkt, const OrionCmd_t* Cmd);

//! Decode the OrionStartupCmd packet
int decodeOrionStartupCmdPacket(const void* pkt, OrionCmd_t* Cmd);

//! return the packet ID for the OrionStartupCmd packet
#define getOrionStartupCmdPacketID() (ORION_PKT_STARTUP_CMD)

//! return the minimum encoded length for the OrionStartupCmd packet
#define getOrionStartupCmdMinDataLength() (2*NUM_GIMBAL_AXES+3)

//! return the maximum encoded length for the OrionStartupCmd packet
#define getOrionStartupCmdMaxDataLength() (2*NUM_GIMBAL_AXES+3)

typedef enum
{
    POSITION_HOME,   //!< Home position, used on startup
    POSITION_STOW,   //!< Stow position, currently unused
    POSITION_RETRACT,//!< Position to stow the gimbal at prior to retracting
    POSITION_FFC,    //!< FFC position, currently unused
    POSITION_USER_0, //!< User-defined position 0
    POSITION_USER_1, //!< User-defined position 1
    NUM_POSITIONS    
} PositionList;

typedef struct
{
    float    Pan;     //!< Pan angle
    float    Tilt;    //!< Tilt angle
    uint32_t Enabled; //!< Set to 1 to enable this position
}PosPreset_t;

/*!
 * Stored gimbal positions
 */
typedef struct
{
    uint8_t     NumPositions;             //!< Number of pre-defined positions included in the packet
    PosPreset_t PosPreset[NUM_POSITIONS];
}OrionPositions_t;

//! Create the OrionPositions packet
void encodeOrionPositionsPacketStructure(void* pkt, const OrionPositions_t* user);

//! Decode the OrionPositions packet
int decodeOrionPositionsPacketStructure(const void* pkt, OrionPositions_t* user);

//! return the packet ID for the OrionPositions packet
#define getOrionPositionsPacketID() (ORION_PKT_POSITIONS)

//! return the minimum encoded length for the OrionPositions packet
#define getOrionPositionsMinDataLength() (1)

//! return the maximum encoded length for the OrionPositions packet
#define getOrionPositionsMaxDataLength() (NUM_POSITIONS*8+1)

/*!
 * Options controlling how the geopoint is interpreted
 */
typedef enum
{
    geopointNone = 0x00,         //!< No geopoint options set.
    geopointStare = 0x01,        //!< If set this geopoint will issue a stare packet when it is pointing at the target location. This option is ignored if joystickRange is non-zero.
    geopointClosure = 0x02,      //!< If set this geopoint command will cause the gimbal to enter closure mode, in which it will drive at maximum performance to achieve the desired pointing. This option is ignored if the joystickRange is non-zero.
    geopointStareClosure = 0x03, //!< Logical OR of geopointStare and geopointClosure.
    geopointReturnToMode = 0x04  //!< Set this bit to return to the current operation mode after the closure threshold is reached
} geopointOptions;

/*!
 * Send this packet to command the gimbal to go to Geopoint mode. In geopoint
 * the gimbal looks at a target as given by a latitude, longitude, altitude
 * position. The geopoint command can include a target velocity, which will
 * cause the gimbal to smoothly move its stare point as it propagates the target
 * position. Geopoint mode is canceled by sending a normal OrionCmd packet.
 */
typedef struct
{
    double          targetLat;       //!< Geodetic latitude of the target in radians, positive North
    double          targetLon;       //!< Longitude of the target in radians, positive East
    double          targetAlt;       //!< Altitude of the target in meters above the WGS-84 ellipsoid
    float           targetVelNED[3]; //!< Velocity of the target in North, East, Down meters per second
    float           joystickRange;   //!< Estimated range to target in meters. If non-zero *and* if geopoint is already running the position information in this packet is ignored and only the velocity and range information is used to propagate the geopoint command position. This is used for cases where a joystick is being used to drive the geopoint. If the gimbal has its own range estimate then a non-zero joystickRange will be replaced with the gimbal's internal range estimate. If you want the gimbal use the joystick mode but you cannot compute the range, use a range less than 10 meters and the gimbal will not do the range adjustment
    geopointOptions options;         //!< Options for the geopoint packet.
}GeopointCmd_t;

//! Create the GeopointCmd packet
void encodeGeopointCmdPacket(void* pkt, double targetLat, double targetLon, double targetAlt, const float targetVelNED[3], float joystickRange, geopointOptions options);

//! Decode the GeopointCmd packet
int decodeGeopointCmdPacket(const void* pkt, double* targetLat, double* targetLon, double* targetAlt, float targetVelNED[3], float* joystickRange, geopointOptions* options);

//! return the packet ID for the GeopointCmd packet
#define getGeopointCmdPacketID() (ORION_PKT_GEOPOINT_CMD)

//! return the minimum encoded length for the GeopointCmd packet
#define getGeopointCmdMinDataLength() (18)

//! return the maximum encoded length for the GeopointCmd packet
#define getGeopointCmdMaxDataLength() (21)

/*!
 * Maximum number of points in a path.
 */
typedef enum
{
    MAX_PATH_POINTS = 15 //!< Maximum number of points in a path
} maxPathPoints;

/*!
 * List of path points
 */
typedef struct
{
    float posEcef[3]; //!< ECEF position in meters
}Point_t;

/*!
 * The path packet contains a series of waypoints that define a path in 3D
 * space. Sending this packet enables the path track logic, which will cause the
 * gimbal to look at the nearest point on the path; or look directly downward.
 * Path mode is canceled by sending a normal OrionCmd packet.
 */
typedef struct
{
    uint8_t  numPoints;              //!< Number of points in the path
    unsigned pointDown : 1;          //!< If numPoints is zero, and this is set, then the gimbal will point downwards
    unsigned numCrossTrackSteps : 4; //!< Number of steps for across track stepping. Must be more than 1 to enable cross track stepping.
    Point_t  Point[MAX_PATH_POINTS]; //!< List of path points
    float    alongTrackStepAngle;    //!< Angle in radians for step-stare functionality along track. Set to zero for no step-stare. If doing downward pointing the gimbal must be receiving ORION_PKT_RANGE_DATA.
    float    crossTrackStepRatio;    //!< Ratio of cross track step angle to along track step angle. Set to zero for no cross track stepping.
}OrionPath_t;

//! Create the OrionPath packet
void encodeOrionPathPacketStructure(void* pkt, const OrionPath_t* user);

//! Decode the OrionPath packet
int decodeOrionPathPacketStructure(const void* pkt, OrionPath_t* user);

//! return the packet ID for the OrionPath packet
#define getOrionPathPacketID() (ORION_PKT_PATH)

//! return the minimum encoded length for the OrionPath packet
#define getOrionPathMinDataLength() (2)

//! return the maximum encoded length for the OrionPath packet
#define getOrionPathMaxDataLength() (MAX_PATH_POINTS*9+5)

//! Create the StareAck packet
void encodeStareAckPacket(void* pkt, uint32_t echoSystemTime);

//! Decode the StareAck packet
int decodeStareAckPacket(const void* pkt, uint32_t* echoSystemTime);

//! return the packet ID for the StareAck packet
#define getStareAckPacketID() (ORION_PKT_STARE_ACK)

//! return the minimum encoded length for the StareAck packet
#define getStareAckMinDataLength() (4)

//! return the maximum encoded length for the StareAck packet
#define getStareAckMaxDataLength() (4)

//! Create the GeoidUndulation packet
void encodeGeoidUndulationPacket(void* pkt, float Undulation);

//! Decode the GeoidUndulation packet
int decodeGeoidUndulationPacket(const void* pkt, float* Undulation);

//! return the packet ID for the GeoidUndulation packet
#define getGeoidUndulationPacketID() (ORION_PKT_GEOID_UNDULATION)

//! return the minimum encoded length for the GeoidUndulation packet
#define getGeoidUndulationMinDataLength() (2)

//! return the maximum encoded length for the GeoidUndulation packet
#define getGeoidUndulationMaxDataLength() (2)

//! Create the OrionCameraSwitch packet
void encodeOrionCameraSwitchPacket(void* pkt, uint8_t Index);

//! Decode the OrionCameraSwitch packet
int decodeOrionCameraSwitchPacket(const void* pkt, uint8_t* Index);

//! return the packet ID for the OrionCameraSwitch packet
#define getOrionCameraSwitchPacketID() (ORION_PKT_CAMERA_SWITCH)

//! return the minimum encoded length for the OrionCameraSwitch packet
#define getOrionCameraSwitchMinDataLength() (1)

//! return the maximum encoded length for the OrionCameraSwitch packet
#define getOrionCameraSwitchMaxDataLength() (1)

/*!
 * Command a camera in the gimbal.
 */
typedef struct
{
    float   Zoom;  //!< Digital zoom ratio
    float   Focus; //!< Focus command/position
    uint8_t Index; //!< The index of the camera to command
}OrionCameraState_t;

//! Create the OrionCameraState packet
void encodeOrionCameraStatePacket(void* pkt, float Zoom, float Focus, uint8_t Index);

//! Decode the OrionCameraState packet
int decodeOrionCameraStatePacket(const void* pkt, float* Zoom, float* Focus, uint8_t* Index);

//! return the packet ID for the OrionCameraState packet
#define getOrionCameraStatePacketID() (ORION_PKT_CAMERA_STATE)

//! return the minimum encoded length for the OrionCameraState packet
#define getOrionCameraStateMinDataLength() (2)

//! return the maximum encoded length for the OrionCameraState packet
#define getOrionCameraStateMaxDataLength() (5)

/*!
 * FLIR NUC type enumeration
 */
typedef enum
{
    NUC_TYPE_MANUAL,     //!< Typical operation mode, manual FFC only
    NUC_TYPE_SSN_NO_MOTION,//!< Silent shutterless NUC (SSN), no motion setting
    NUC_TYPE_SSN_LOW,    //!< Silent shutterless NUC (SSN), low setting
    NUC_TYPE_SSN_MEDIUM, //!< Silent shutterless NUC (SSN), medium setting
    NUC_TYPE_SSN_HIGH    //!< Silent shutterless NUC (SSN), high setting
} FlirNucType_t;

/*!
 * FLIR AGC type enumeration
 */
typedef enum
{
    AGC_TYPE_DEFAULT,    
    AGC_TYPE_AUTO_LINEAR 
} FlirAgcType_t;

/*!
 * FLIR-specific camera settings.
 */
typedef struct
{
    uint8_t       Index;           //!< Index of the camera that these settings should apply to. Use 0xFF to apply to any connected FLIR camera.
    unsigned      DisableSffc : 1;
    unsigned      Palette : 3;    
    FlirNucType_t NucType;         //!< NUC type setting
    unsigned      BlackHot : 1;    //!< Image polarity setting - set to 0 for white hot or 1 for black hot. This field is ignored if Palette is non-zero, (default=0, effective min=0, effective max=1)
    uint8_t       MaxAgcGain;      //!< Maximum AGC output gain, (effective min=1, effective max=50)
    int8_t        AceLevel;        //!< Active Contrast Enhancement (ACE) level, (default=1, effective min=-8, effective max=8)
    uint8_t       DdeThreshold;    //!< DDE spatial threshold, (default=24, effective min=1, effective max=100)
    uint8_t       AgcMidpoint;     //!< AGC output midpoint, (default=128, effective min=0, effective max=255)
    float         IntegrationTime; //!< Integration time, in milliseconds, (default=8, effective min=2, effective max=12)
    FlirAgcType_t AgcType;        
}OrionFlirSettings_t;

//! Create the OrionFlirSettings packet
void encodeOrionFlirSettingsPacketStructure(void* pkt, const OrionFlirSettings_t* user);

//! Decode the OrionFlirSettings packet
int decodeOrionFlirSettingsPacketStructure(const void* pkt, OrionFlirSettings_t* user);

//! return the packet ID for the OrionFlirSettings packet
#define getOrionFlirSettingsPacketID() (ORION_PKT_FLIR_SETTINGS)

//! return the minimum encoded length for the OrionFlirSettings packet
#define getOrionFlirSettingsMinDataLength() (5)

//! return the maximum encoded length for the OrionFlirSettings packet
#define getOrionFlirSettingsMaxDataLength() (8)

/*!
 * Aptina-specific camera settings.
 */
typedef struct
{
    uint8_t  Index;           //!< Index of the camera that these settings should apply to. Use 0xFF to apply to any connected Aptina camera.
    float    MinExposure;     //!< Minimum exposure time in milliseconds, (default=0.1, effective min=0.05, effective max=33.0)
    float    MaxExposure;     //!< Maximum exposure time in milliseconds, (default=8.0, effective min=0.05, effective max=33.0)
    float    MinGain;         //!< Minimum sensor luminance gain, (default=1, effective min=1, effective max=32)
    float    MaxGain;         //!< Maximum sensor luminance gain, (default=32, effective min=1, effective max=32)
    int8_t   Brightness;      //!< Brightness adjustment, (default=-8, effective min=-100, effective max=110)
    float    Contrast;        //!< Contrast adjustment, (default=-0.4, effective min=-1.0, effective max=1.0)
    float    Saturation;      //!< Saturation adjustment, (default=0.3, effective min=-1.0, effective max=1.0)
    float    Sharpness;       //!< Sharpening filter strength, (default=2.0, effective min=0.0, effective max=5.0)
    unsigned DebugEnable : 1; //!< Set to 1 to enable AGC debugging information, (default=0, effective min=0, effective max=1)
    int8_t   Hue;             //!< Hue adjustment, (default=0, effective min=-10, effective max=10)
    float    Aperture;        //!< Aperture command, set to 0 for auto
    float    MinAperture;     //!< Minimum aperture setting, or 0 for not supported
    float    MaxAperture;     //!< Maximum aperture setting, or 0 for not supported
}OrionAptinaSettings_t;

//! Create the OrionAptinaSettings packet
void encodeOrionAptinaSettingsPacketStructure(void* pkt, const OrionAptinaSettings_t* user);

//! Decode the OrionAptinaSettings packet
int decodeOrionAptinaSettingsPacketStructure(const void* pkt, OrionAptinaSettings_t* user);

//! return the packet ID for the OrionAptinaSettings packet
#define getOrionAptinaSettingsPacketID() (ORION_PKT_APTINA_SETTINGS)

//! return the minimum encoded length for the OrionAptinaSettings packet
#define getOrionAptinaSettingsMinDataLength() (13)

//! return the maximum encoded length for the OrionAptinaSettings packet
#define getOrionAptinaSettingsMaxDataLength() (18)

/*!
 * Zafiro-specific camera settings.
 */
typedef struct
{
    uint8_t Index;              //!< Index of the camera that these settings should apply to. Use 0xFF to apply to any connected Zafiro camera.
    uint8_t BlackHot;           //!< Image polarity setting - set to 0 for white hot or 1 for black hot, (default=0, effective min=0, effective max=1)
    float   IntegrationTime;    //!< Integration time, in milliseconds, (default=10.0, effective min=1.0, effective max=30.0)
    uint8_t LapEnabled;         //!< Local Area Processing (LAP) enable/disable flag. Set to zero to disable, or non-zero to enable, (default=1, effective min=0, effective max=1)
    float   LapGain;            //!< LAP Sharpening gain, (default=2.0, effective min=0.5, effective max=4.0)
    float   AgcSaturation;      //!< AGC histogram saturation, (default=0.01, effective min=0.0, effective max=0.1)
    uint8_t UseNucTablePresets; //!< Set to 1 to use NUC table presets, (default=0, effective min=0, effective max=1)
}OrionZafiroSettings_t;

//! Create the OrionZafiroSettings packet
void encodeOrionZafiroSettingsPacketStructure(void* pkt, const OrionZafiroSettings_t* user);

//! Decode the OrionZafiroSettings packet
int decodeOrionZafiroSettingsPacketStructure(const void* pkt, OrionZafiroSettings_t* user);

//! return the packet ID for the OrionZafiroSettings packet
#define getOrionZafiroSettingsPacketID() (ORION_PKT_ZAFIRO_SETTINGS)

//! return the minimum encoded length for the OrionZafiroSettings packet
#define getOrionZafiroSettingsMinDataLength() (6)

//! return the maximum encoded length for the OrionZafiroSettings packet
#define getOrionZafiroSettingsMaxDataLength() (7)

/*!
 * Hitachi-specific camera settings.
 */
typedef struct
{
    uint8_t Index;           //!< Index of the camera that these settings should apply to. Use 0xFF to apply to any connected Hitachi camera.
    int16_t IntegrationTime; //!< Integration time in microseconds, or negative to disable shutter-priority mode, (default=-1, effective min=100, effective max=16667)
    float   Aperture;        //!< Aperture f-number, or negative to disable aperture-priority mode, (default=1.4, effective min=-3276.6, effective max=3276.7)
    float   Sharpness;       //!< Sharpening filter strength, (default=1.0, effective min=0.0, effective max=5.0)
    uint8_t NightMode;       //!< Set to 1 to remove IR cut filter, or 0 to enable it, (default=0, effective min=0, effective max=1)
}OrionHitachiSettings_t;

//! Create the OrionHitachiSettings packet
void encodeOrionHitachiSettingsPacketStructure(void* pkt, const OrionHitachiSettings_t* user);

//! Decode the OrionHitachiSettings packet
int decodeOrionHitachiSettingsPacketStructure(const void* pkt, OrionHitachiSettings_t* user);

//! return the packet ID for the OrionHitachiSettings packet
#define getOrionHitachiSettingsPacketID() (ORION_PKT_HITACHI_SETTINGS)

//! return the minimum encoded length for the OrionHitachiSettings packet
#define getOrionHitachiSettingsMinDataLength() (5)

//! return the maximum encoded length for the OrionHitachiSettings packet
#define getOrionHitachiSettingsMaxDataLength() (7)

/*!
 * Sony-specific camera settings.
 */
typedef struct
{
    uint8_t Index;       //!< Index of the camera that these settings should apply to. Use 0xFF to apply to any connected Sony camera.
    float   MinExposure; //!< Minimum exposure time in milliseconds, (default=0.1, effective min=0.05, effective max=33.0)
    float   MaxExposure; //!< Maximum exposure time in milliseconds, (default=0.1, effective min=0.05, effective max=33.0)
    uint8_t MinGain;     //!< Minimum sensor luminance gain, in dB, (default=1)
    uint8_t MaxGain;     //!< Maximum sensor luminance gain, in dB, (default=18)
    uint8_t Brightness;  //!< Brightness target, from 0 to 255, (default=128, effective min=0, effective max=255)
    float   Contrast;    //!< Contrast adjustment, (default=-0.3, effective min=-1.0, effective max=1.0)
    float   Saturation;  //!< Saturation adjustment, (default=0.5, effective min=-1.0, effective max=1.0)
    float   Sharpness;   //!< Sharpening filter strength, (default=3.0, effective min=0.0, effective max=5.0)
    float   FrameRate;   //!< Camera frame rate, in Hertz, (default=30.0, effective min=1.0, effective max=30.0)
}OrionSonySettings_t;

//! Create the OrionSonySettings packet
void encodeOrionSonySettingsPacketStructure(void* pkt, const OrionSonySettings_t* user);

//! Decode the OrionSonySettings packet
int decodeOrionSonySettingsPacketStructure(const void* pkt, OrionSonySettings_t* user);

//! return the packet ID for the OrionSonySettings packet
#define getOrionSonySettingsPacketID() (ORION_PKT_SONY_SETTINGS)

//! return the minimum encoded length for the OrionSonySettings packet
#define getOrionSonySettingsMinDataLength() (12)

//! return the maximum encoded length for the OrionSonySettings packet
#define getOrionSonySettingsMaxDataLength() (12)

/*!
 * KTnC-specific camera settings.
 */
typedef struct
{
    uint8_t  Index;               //!< Index of the camera that these settings should apply to. Use 0xFF to apply to any connected KTnC camera.
    int16_t  IntegrationTime;     //!< Integration time in microseconds, or negative to disable shutter-priority mode, (default=-1, auto=-1, effective min=100, effective max=16667)
    float    Aperture;            //!< Aperture f-number, or negative to disable aperture-priority mode, (default=-1, auto=-1, effective min=1.6, effective max=32)
    uint8_t  Sharpness;           //!< Sharpening adjustment, (default=8, effective min=0, effective max=16)
    uint8_t  VerticalFlip;        //!< Set to non-zero to vertically flip the video, (default=0, effective min=0, effective max=1)
    uint8_t  ExposureComp;        //!< Exposure compenstation adjustment, (default=7, effective min=0, effective max=14)
    uint8_t  Contrast;            //!< Contrast adjustment, (default=8 effective min=0, effective max=32)
    uint8_t  Saturation;          //!< Saturation adjustment, (default=14, effective min=0, effective max=32)
    unsigned NightMode : 1;       //!< Night mode enable, (default=0, effective min=0, effective max=1)
    unsigned ResetToDefaults : 1; //!< Reset to defaults, (default=0, effective min=0, effective max=1)
    unsigned HasMaxExposure : 1;  //!< The gimbal will set this flag to 1 if MaxExposure is supported by the camera
    float    MaxExposure;         //!< Max integration time in seconds for AGC algorithm
    uint8_t  VersionMajor;        //!< Major version number of the firmware loaded on the camera
    uint8_t  VersionMinor;        //!< Minor version number of the firmware loaded on the camera
    uint8_t  VersionPatch;        //!< Patch version number of the firmware loaded on the camera
}OrionKtncSettings_t;

//! Create the OrionKtncSettings packet
void encodeOrionKtncSettingsPacketStructure(void* pkt, const OrionKtncSettings_t* user);

//! Decode the OrionKtncSettings packet
int decodeOrionKtncSettingsPacketStructure(const void* pkt, OrionKtncSettings_t* user);

//! return the packet ID for the OrionKtncSettings packet
#define getOrionKtncSettingsPacketID() (ORION_PKT_KTNC_SETTINGS)

//! return the minimum encoded length for the OrionKtncSettings packet
#define getOrionKtncSettingsMinDataLength() (5)

//! return the maximum encoded length for the OrionKtncSettings packet
#define getOrionKtncSettingsMaxDataLength() (16)

//! Create the OrionRetractCommand packet
void encodeOrionRetractCommandPacket(void* pkt, OrionRetractCmd_t Cmd);

//! Decode the OrionRetractCommand packet
int decodeOrionRetractCommandPacket(const void* pkt, OrionRetractCmd_t* Cmd);

//! return the packet ID for the OrionRetractCommand packet
#define getOrionRetractCommandPacketID() (ORION_PKT_RETRACT_CMD)

//! return the minimum encoded length for the OrionRetractCommand packet
#define getOrionRetractCommandMinDataLength() (2)

//! return the maximum encoded length for the OrionRetractCommand packet
#define getOrionRetractCommandMaxDataLength() (2)

/*!
 * This packet can be used to transfer user-defined data payloads between
 * communication ports on the gimbal.
 */
typedef struct
{
    UserDataPort_t port;      //!< Destination crown board communication port identifier
    uint8_t        size;      //!< User data array size in bytes
    uint32_t       id;        //!< User-defined unique identifier or sequence number for this data block
    uint8_t        data[128]; //!< User data byte array
}OrionUserData_t;

//! Create the OrionUserData packet
void encodeOrionUserDataPacketStructure(void* pkt, const OrionUserData_t* user);

//! Decode the OrionUserData packet
int decodeOrionUserDataPacketStructure(const void* pkt, OrionUserData_t* user);

//! return the packet ID for the OrionUserData packet
#define getOrionUserDataPacketID() (ORION_PKT_USER_DATA)

//! return the minimum encoded length for the OrionUserData packet
#define getOrionUserDataMinDataLength() (6)

//! return the maximum encoded length for the OrionUserData packet
#define getOrionUserDataMaxDataLength() (134)

/*!
 * Command to fire the laser (if installed).
 */
typedef struct
{
    uint8_t  Index;        //!< Index of the laser to apply this command to
    char     Password[16]; //!< Password, if required by the laser. If a password is required, it must be provided in order to change any aspect of the laser's state (e.g., enable/disable, arm/disarm, fire/deactivate
    uint8_t  Enable;       //!< Set to zero to disable the laser, or non-zero to enable it
    uint8_t  Arm;          //!< Set to zero to disarm the laser, or non-zero to arm
    uint8_t  Fire;         //!< Set to zero to deactivate the laser, or non-zero to activate it
    uint16_t OnTime;       //!< Periodic laser pulse on time, in milliseconds, or zero to fire continuously
    uint16_t OffTime;      //!< Periodic laser pulse off time, in milliseconds, or zero to fire continuously
    uint16_t PrfCode;      //!< Laser PRF code, if applicable
    uint8_t  SafetyBypass; //!< Set to a non-zero value to bypass all laser safety checks
}OrionLaserCommand_t;

//! Create the OrionLaserCommand packet
void encodeOrionLaserCommandPacketStructure(void* pkt, const OrionLaserCommand_t* user);

//! Decode the OrionLaserCommand packet
int decodeOrionLaserCommandPacketStructure(const void* pkt, OrionLaserCommand_t* user);

//! return the packet ID for the OrionLaserCommand packet
#define getOrionLaserCommandPacketID() (ORION_PKT_LASER_CMD)

//! return the minimum encoded length for the OrionLaserCommand packet
#define getOrionLaserCommandMinDataLength() (11)

//! return the maximum encoded length for the OrionLaserCommand packet
#define getOrionLaserCommandMaxDataLength() (29)

/*!
 * Information about the current state of lasers installed in the gimbal.
 */
typedef struct
{
    uint8_t           NumLasers;         //!< Number of installed lasers
    OrionLaserState_t State[MAX_LASERS];
}OrionLaserStates_t;

//! Create the OrionLaserStates packet
void encodeOrionLaserStatesPacketStructure(void* pkt, const OrionLaserStates_t* user);

//! Decode the OrionLaserStates packet
int decodeOrionLaserStatesPacketStructure(const void* pkt, OrionLaserStates_t* user);

//! return the packet ID for the OrionLaserStates packet
#define getOrionLaserStatesPacketID() (ORION_PKT_LASER_STATES)

//! return the minimum encoded length for the OrionLaserStates packet
#define getOrionLaserStatesMinDataLength() (1)

//! return the maximum encoded length for the OrionLaserStates packet
#define getOrionLaserStatesMaxDataLength() (MAX_LASERS*6+1)

/*!
 * Protocols understood by the Orion UART configuration
 */
typedef enum
{
    PROTOCOL_NO_CHANGE,      //!< Do not change the protocol
    PROTOCOL_NONE,           //!< Disable the port
    PROTOCOL_DEFAULT,        //!< Use the default protocol. This is port dependent
    PROTOCOL_ORION,          //!< Orion packet communications protocol
    PROTOCOL_CLEVIS,         //!< Orion packet communications protocol specific to the clevis
    PROTOCOL_CLEVIS_RAW,     //!< Clevis raw communications mode
    PROTOCOL_NMEA_GPS,       //!< GPS input over NMEA
    PROTOCOL_UBLOX_GPS,      //!< uBox GPS
    PROTOCOL_NOVATEL_GPS,    //!< Novatel GPS
    PROTOCOL_MAVLINK_GPS,    //!< Mavlink GPS
    PROTOCOL_UM7_MAG,        //!< CH Robotics UM7 magnetometer
    PROTOCOL_SIGHTLINE_VIDEO,//!< Sightline video processing
    PROTOCOL_SENSONOR_IMU,   //!< Sensonor IMU
    PROTOCOL_DMU11_IMU,      //!< Silicon sensing IMU
    PROTOCOL_DISCOVERY,      //!< Discovery protocol that decides between novatel, UM7, and Sightline
    PROTOCOL_AIRROBOT,       //!< Air robot protocol
    PROTOCOL_PROPRIETARY1,   //!< Proprietary protocol
    PROTOCOL_PROPRIETARY2,   //!< Proprietary protocol
    PROTOCOL_FLIR,           //!< FLIR pass-through protocol
    PROTOCOL_EPSON_IMU,      //!< EPSON IMU protocol
    PROTOCOL_PIKSI,          //!< Swift Piksi GPS
    PROTOCOL_WEPILOT,        //!< WePilot AP
    PROTOCOL_ETHERNET,       //!< Ethernet serial pass-through
    PROTOCOL_VECTORNAV,      //!< VectorNav IMU
    NUM_PROTOCOL             
} OrionProtocols_t;

/*!
 * This packet is used to change or request the baud rate and protocol of a UART
 * on the crown board. Send this packet with zero bytes to request the
 * configuration of the port that receives the request, or with 1 byte to
 * request the configuration of a specific port. Not all port configuration
 * options are available, the ethernet port must run the PROTOCOL_ORION protocol
 * at either 115200 or 230400 bits per second. In general users should not
 * change the ethernet port setup. In addition the PROTOCOL_UBLOX_GPS is not
 * supported on any user configurable port, it is included in the protocol list
 * only for completeness.
 */
typedef struct
{
    UserDataPort_t   port;      //!< The port whose configuration should be changed or requested, use USER_DATA_PORT_CURRENT to indicate the port which received this packet
    uint32_t         baud;      //!< Baud rate bits per second. Use 0 to select the default baud rate for this port and protocol.
    OrionProtocols_t protocol;  //!< The protocol to use for this port. If PROTOCOL_NO_CHANGE or PROTOCOL_DEFAULT are used the reply to this packet will contain the actual protocol in use
    uint8_t          temporary; //!< A value of 0 indicates that the settings should persist across power cycles. Non-zero values will cause the new setting to be lost after power cycle
    uint32_t         param;     //!< Protocol-specific parameter, default is zero
}OrionUartConfig_t;

//! Create the OrionUartConfig packet
void encodeOrionUartConfigPacketStructure(void* pkt, const OrionUartConfig_t* user);

//! Decode the OrionUartConfig packet
int decodeOrionUartConfigPacketStructure(const void* pkt, OrionUartConfig_t* user);

//! return the packet ID for the OrionUartConfig packet
#define getOrionUartConfigPacketID() (ORION_PKT_UART_CONFIG)

//! return the minimum encoded length for the OrionUartConfig packet
#define getOrionUartConfigMinDataLength() (5)

//! return the maximum encoded length for the OrionUartConfig packet
#define getOrionUartConfigMaxDataLength() (10)

/*!
 * Gimbal limits of operation. This includes the max and min pan and tilt
 * angles, as well as the angular rate and the maximum current consumption.
 */
typedef struct
{
    float MinPos[NUM_GIMBAL_AXES];      //!< Minimum position in radians
    float MaxPos[NUM_GIMBAL_AXES];      //!< Maximum position in radians
    float MaxVel[NUM_GIMBAL_AXES];      //!< Maximum velocity in radians per second
    float MaxAccel[NUM_GIMBAL_AXES];    //!< Maximum acceleration in radians per second per second
    float ContCur[NUM_GIMBAL_AXES];     //!< Maximum continuous current in Amps
    float PeakCur[NUM_GIMBAL_AXES];     //!< Maximum peak current in Amps
    float PeakCurTime[NUM_GIMBAL_AXES]; //!< Peak current time in seconds
    float InitCur[NUM_GIMBAL_AXES];     //!< Initialization current in Amps
    float MaxPower[NUM_GIMBAL_AXES];    //!< Maximum motor output power, in watts. Set to zero for no limit
}OrionLimitsData_t;

//! Create the OrionLimitsData packet
void encodeOrionLimitsDataPacketStructure(void* pkt, const OrionLimitsData_t* user);

//! Decode the OrionLimitsData packet
int decodeOrionLimitsDataPacketStructure(const void* pkt, OrionLimitsData_t* user);

//! return the packet ID for the OrionLimitsData packet
#define getOrionLimitsDataPacketID() (ORION_PKT_LIMITS)

//! return the minimum encoded length for the OrionLimitsData packet
#define getOrionLimitsDataMinDataLength() (16*NUM_GIMBAL_AXES)

//! return the maximum encoded length for the OrionLimitsData packet
#define getOrionLimitsDataMaxDataLength() (17*NUM_GIMBAL_AXES)

/*!
 * INS options give configuration options for the inertial navigation system
 * (INS) in the gunbal. Changing the INS options will cause the INS to be
 * restarted if the platform rotation changes. When using platform rotation note
 * the order: First yaw about the gimbal's z-axis to create an intermediate
 * axis. Then pitch about the intermediate y-axis to create a second
 * intermediate axis. Finally roll about the second intermediate x-axis to reach
 * the platform orientation. When using an IMU in the payload ball the
 * enablePlatformRotation can still be used, but will only effect heading
 * observations and the GPS lever arm, it will not rotate the IMU data.
 */
typedef struct
{
    unsigned enablePlatformRotation : 1;      //!< The INS will be run in the platform reference frame if this is set. The platform reference frame is defined by the rotation from the gimbal reference frame to the platform frame. Set this if the gimbal is installed such that the gimbal reference frame is often near pitch of +/- 90 degrees.
    unsigned enableCourseIsHeading : 1;       //!< If set then the INS will use the course of the GPS as a heading input for initialization and heading updates when the heading confidence is poor. This is appropriate for fixed wing aircraft if enablePlatformRotation is set (or if the gimbal native axis is aligned with the aircraft axis).
    unsigned disableMagnetometer : 1;         //!< If set then the INS will ignore any magnetometer measurements.
    unsigned disableGPS : 1;                  //!< If set then the INS will ignore any GPS measurements.
    unsigned resetINS : 1;                    //!< If set then the INS will be reset, all other fields of this packet are ignored in that case.
    unsigned disableGpsClockError : 1;        //!< Set this to disable clock error estimation for tightly coupled INS.
    unsigned enableAccelBias : 1;             //!< Set this to enable accelerometer bias estimation.
    unsigned enableTightlyCoupled : 1;        //!< Set this to enable the tightly coupled INS.
    unsigned usePhaseForVelocity : 1;         //!< If set the INS will use the carrier phase rate for tightly coupled velocity observations. Otherwise the tightly coupled velocity observations come from doppler shifts.
    unsigned disableL1 : 1;                   //!< If set the INS will ignore L1 band for tightly coupled observations.
    unsigned disableL2 : 1;                   //!< If set the INS will ignore the L2 band for tightly coupled observations.
    unsigned disableL5 : 1;                   //!< If set the INS will ignore the L5 band for tightly coupled observations.
    float    elevationMask;                   //!< Elevation mask for tightly coupled satellites
    unsigned enablePayloadIns : 1;            //!< If set the IMU inputs to the INS are coming from the payload ball, not the gimbal crown. Note that enablePlatformRotation is interpreted differently in that case
    unsigned enableNonLinearHeading : 1;      //!< If set then the INS will attempt to observe the heading use nonlinear methods. This may be helpful for hovering vehicles that do not have any other heading observation.
    unsigned enableSensonorMV : 1;            //!< If set, and if enablePayloadIns is set, the Sensonor IMU inputs to the INS are coming from the payload ball in the HD80MV orientation.
    unsigned enableHD25PayloadINS : 1;        //!< If set, and if enablePayloadIns is set, the IMU inputs to the INS are coming from the payload ball in the HD25 special orientation.
    unsigned opticalFlowSetting : 4;          //!< Non-zero to enable optical flow.
    unsigned enableCustomIMURotation : 1;     //!< Set to enable a custom rotation from IMU axis to INS axis. Should not be set at the same time as `enableSensonorMV`.
    float    gimbalToPlatformEuler[NUM_AXES]; //!< Roll, Pitch, Yaw angles in radians from -pi to pi. The angles give the Euler rotation (yaw first, then pitch, then roll) from the platform reference frame into the gimbal reference frame.
    float    initialHeading;                  //!< Initial heading angle in radians for the INS
    float    gpsLeverArm[3];                  //!< X, Y, Z meters from first (primary) GPS antenna to IMU in the gimbal reference frame, or the platform reference frame if enablePlatformRotation is on
    float    headingObservationBiasAngle;     //!< For external heading observations (including magnetometer) subtract this angle in radians from the heading observation to get the heading in INS or platform frame
    float    secondGPSLeverArm[3];            //!< X, Y, Z meters from second GPS antenna to IMU in the gimbal reference frame, or the platform reference frame if enablePlatformRotation is on. This only applies if Novatel Align data are being received.
    float    alignHeadingNoise;               //!< Sensor noise in radians for align heading observation. Use zero for the default sensor noise from the Align hardware.
    float    imuToInsEuler[NUM_AXES];         //!< Roll, Pitch, Yaw angles in radians from -pi to pi. The angles give the Euler rotation (yaw first, then pitch, then roll) from the INS reference frame into the IMU reference frame.
}InsOptions_t;

//! Create the InsOptions packet
void encodeInsOptionsPacketStructure(void* pkt, const InsOptions_t* user);

//! Decode the InsOptions packet
int decodeInsOptionsPacketStructure(const void* pkt, InsOptions_t* user);

//! return the packet ID for the InsOptions packet
#define getInsOptionsPacketID() (ORION_PKT_INS_OPTIONS)

//! return the minimum encoded length for the InsOptions packet
#define getInsOptionsMinDataLength() (2*NUM_AXES+6)

//! return the maximum encoded length for the InsOptions packet
#define getInsOptionsMaxDataLength() (4*NUM_AXES+22)

/*!
 * Change the IP network settings in the gimbal.
 */
typedef struct
{
    uint32_t Ip;               //!< IPv4 address
    uint32_t Mask;             //!< IPv4 network mask
    uint32_t Gateway;          //!< IPv4 gateway address
    uint8_t  LowDelay;         //!< Set to 1 to use low-delay TCP mode (i.e. disable Nagle's Algorithm).
    uint16_t Mtu;              //!< Ethernet MTU size, set to zero for hardware default
    uint16_t SecondaryTcpPort; //!< Port number for secondary TCP server port; set to zero to disable
    uint8_t  LowBandwidth;     //!< Set to 1 to use low-bandwidth mode (i.e., disable geolocate telemetry downlink
}OrionNetworkSettings_t;

//! Create the OrionNetworkSettings packet
void encodeOrionNetworkSettingsPacketStructure(void* pkt, const OrionNetworkSettings_t* user);

//! Decode the OrionNetworkSettings packet
int decodeOrionNetworkSettingsPacketStructure(const void* pkt, OrionNetworkSettings_t* user);

//! return the packet ID for the OrionNetworkSettings packet
#define getOrionNetworkSettingsPacketID() (ORION_PKT_NETWORK_SETTINGS)

//! return the minimum encoded length for the OrionNetworkSettings packet
#define getOrionNetworkSettingsMinDataLength() (12)

//! return the maximum encoded length for the OrionNetworkSettings packet
#define getOrionNetworkSettingsMaxDataLength() (18)

/*!
 * Change the IP network settings in the gimbal.
 */
typedef struct
{
    uint8_t  Ip[4];            //!< IPv4 address
    uint8_t  Mask[4];          //!< IPv4 network mask
    uint8_t  Gateway[4];       //!< IPv4 gateway address
    uint8_t  LowDelay;         //!< Set to 1 to use low-delay TCP mode (i.e. disable Nagle's Algorithm).
    uint16_t Mtu;              //!< Ethernet MTU size, set to zero for hardware default
    uint16_t SecondaryTcpPort; //!< Port number for secondary TCP server port; set to zero to disable
    uint8_t  LowBandwidth;     //!< Set to 1 to use low-bandwidth mode (i.e., minimize geolocate telemetry downlink
}OrionNetworkByteSettings_t;

//! Create the OrionNetworkByteSettings packet
void encodeOrionNetworkByteSettingsPacketStructure(void* pkt, const OrionNetworkByteSettings_t* user);

//! Decode the OrionNetworkByteSettings packet
int decodeOrionNetworkByteSettingsPacketStructure(const void* pkt, OrionNetworkByteSettings_t* user);

//! return the packet ID for the OrionNetworkByteSettings packet
#define getOrionNetworkByteSettingsPacketID() (ORION_PKT_NETWORK_SETTINGS)

//! return the minimum encoded length for the OrionNetworkByteSettings packet
#define getOrionNetworkByteSettingsMinDataLength() (12)

//! return the maximum encoded length for the OrionNetworkByteSettings packet
#define getOrionNetworkByteSettingsMaxDataLength() (18)

/*!
 * Network video output stream types
 */
typedef enum
{
    STREAM_TYPE_H264,    //!< h.264+KLV stream in an MPEG transport stream
    STREAM_TYPE_MJPEG,   //!< MJPEG multipart video stream
    STREAM_TYPE_RAW,     //!< Raw multipart video stream
    STREAM_TYPE_YUV,     //!< YUV (NV12) multipart video stream
    STREAM_TYPE_H265,    //!< h.265+KLV stream in an MPEG transport stream
    NUM_STREAM_TYPES,    //!< Number of video stream type IDs
    STREAM_TYPE_NONE = 255 //!< Disable video streaming
} StreamType_t;

/*!
 * Change the IP settings for video delivery.
 */
typedef struct
{
    uint32_t     DestIp;            //!< destination IPv4 address
    uint16_t     Port;              //!< desitnation port
    uint32_t     Bitrate;           //!< Video encoding target bitrate, in bits per second
    int8_t       Ttl;               //!< TTL value for UDP video packets. Values less than or equal to zero will use default values of 64 for unicast and 1 for multicast.
    StreamType_t StreamType;        //!< Output stream format specifier
    uint8_t      MjpegQuality;      //!< MJPEG quality value, from 10 to 95
    unsigned     SaveSettings : 1;  //!< Set to 1 to make h.264 settings non-volatile, or 0 to reset to defaults on startup
    unsigned     TsPacketCount : 4; //!< Number of TS packets per UDP packet, or 0 for no change
    unsigned     FramePeriod : 3;   //!< Set to 0 for no change, or set to N, where the encoder will only render every Nth input frame
}OrionNetworkVideo_t;

//! Create the OrionNetworkVideo packet
void encodeOrionNetworkVideoPacketStructure(void* pkt, const OrionNetworkVideo_t* user);

//! Decode the OrionNetworkVideo packet
int decodeOrionNetworkVideoPacketStructure(const void* pkt, OrionNetworkVideo_t* user);

//! return the packet ID for the OrionNetworkVideo packet
#define getOrionNetworkVideoPacketID() (ORION_PKT_NETWORK_VIDEO)

//! return the minimum encoded length for the OrionNetworkVideo packet
#define getOrionNetworkVideoMinDataLength() (6)

//! return the maximum encoded length for the OrionNetworkVideo packet
#define getOrionNetworkVideoMaxDataLength() (14)

/*!
 * Change the IP settings for video delivery.
 */
typedef struct
{
    uint8_t      DestIp[4];         //!< destination IPv4 address
    uint16_t     Port;              //!< desitnation port
    uint32_t     Bitrate;           //!< Video encoding target bitrate, in bits per second
    int8_t       Ttl;               //!< TTL value for UDP video packets. Values less than or equal to zero will use default values of 64 for unicast and 1 for multicast.
    StreamType_t StreamType;        //!< Output stream format specifier
    uint8_t      MjpegQuality;      //!< MJPEG quality value, from 10 to 95
    unsigned     SaveSettings : 1;  //!< Set to 1 to make h.264 settings non-volatile, or 0 to reset to defaults on startup
    unsigned     TsPacketCount : 4; //!< Number of TS packets per UDP packet, or 0 for no change
    unsigned     FramePeriod : 3;   //!< Set to 0 for no change, or set to N, where the encoder will only render every Nth input frame
}OrionNetworkByteVideo_t;

//! Create the OrionNetworkByteVideo packet
void encodeOrionNetworkByteVideoPacketStructure(void* pkt, const OrionNetworkByteVideo_t* user);

//! Decode the OrionNetworkByteVideo packet
int decodeOrionNetworkByteVideoPacketStructure(const void* pkt, OrionNetworkByteVideo_t* user);

//! return the packet ID for the OrionNetworkByteVideo packet
#define getOrionNetworkByteVideoPacketID() (ORION_PKT_NETWORK_VIDEO)

//! return the minimum encoded length for the OrionNetworkByteVideo packet
#define getOrionNetworkByteVideoMinDataLength() (6)

//! return the maximum encoded length for the OrionNetworkByteVideo packet
#define getOrionNetworkByteVideoMaxDataLength() (14)

/*!
 * The maximum number of cameras in an Orion Gimbal
 */
typedef enum
{
    NUM_CAMERAS = 2  
} OrionNumberOfCameras_t;

/*!
 * The type of camera
 */
typedef enum
{
    CAMERA_TYPE_NONE,    //!< No camera
    CAMERA_TYPE_VISIBLE, //!< Visible light camera
    CAMERA_TYPE_SWIR,    //!< Short wave infrared camera
    CAMERA_TYPE_MWIR,    //!< Mid wave infrared camera
    CAMERA_TYPE_LWIR,    //!< Long wave infrared camera
    CAMERA_TYPE_SPOTTER  //!< Visible light spotter camera
} OrionCameraType_t;

/*!
 * The camera communications protocol
 */
typedef enum
{
    CAMERA_PROTO_UNKNOWN,//!< Protocol unknown or unsupported
    CAMERA_PROTO_FLIR,   //!< FLIR camera
    CAMERA_PROTO_APTINA, //!< Aptina camera
    CAMERA_PROTO_ZAFIRO, //!< Zafiro camera
    CAMERA_PROTO_HITACHI,//!< Hitachi camera
    CAMERA_PROTO_BAE,    //!< BAE camera
    CAMERA_PROTO_SONY,   //!< Sony camera
    CAMERA_PROTO_KTNC,   //!< KTnC camera
    CAMERA_PROTO_ATTOLLO,//!< Attollo camera
    NUM_CAMERA_PROTOS    //!< Number of available camera protocols
} OrionCameraProtocol_t;

/*!
 * Camera settings information
 */
typedef struct
{
    uint8_t               Gpio;                      //!< IO line to activate the camera
    uint8_t               GpioActiveState;           //!< Polarity of Gpio
    OrionCameraType_t     Type;                      //!< The type of camera
    OrionCameraProtocol_t Proto;                     //!< The communications protocol of the camera
    float                 MinFocalLength;            //!< Minimum focal length in millimeters
    float                 MaxFocalLength;            //!< Minimum focal length in millimeters
    float                 PixelPitch;                //!< Spacing of pixels in millimeters
    uint16_t              ArrayWidth;                //!< Number of horizontal pixels in the focal plane array
    uint16_t              ArrayHeight;               //!< Number of vertical pixels in the focal plane array
    float                 FrameRate;                 //!< Frequency at which images are coming off the camera
    float                 AlignMin[NUM_GIMBAL_AXES]; //!< boresight alignment offsets in radians
    float                 AlignMax[NUM_GIMBAL_AXES]; //!< boresight alignment offsets in radians
}OrionCamSettings_t;

/*!
 * Camera definitions for the Orion gimbal
 */
typedef struct
{
    uint8_t            NumCameras;                    //!< The number of cameras installed
    OrionCamSettings_t OrionCamSettings[NUM_CAMERAS]; //!< Camera settings information
}OrionCameras_t;

//! Create the OrionCameras packet
void encodeOrionCamerasPacketStructure(void* pkt, const OrionCameras_t* user);

//! Decode the OrionCameras packet
int decodeOrionCamerasPacketStructure(const void* pkt, OrionCameras_t* user);

//! return the packet ID for the OrionCameras packet
#define getOrionCamerasPacketID() (ORION_PKT_CAMERAS)

//! return the minimum encoded length for the OrionCameras packet
#define getOrionCamerasMinDataLength() (4)

//! return the maximum encoded length for the OrionCameras packet
#define getOrionCamerasMaxDataLength() (4+NUM_CAMERAS*(4*NUM_GIMBAL_AXES+16))

/*!
 * Software version for the clevis board in the Orion gimbal.
 */
typedef struct
{
    char     Version[16];    //!< Version of the clevis board software
    char     PartNumber[16]; //!< Hardware details of the clevis board
    uint32_t OnTime;         //!< Board on time in minutes
}OrionClevisVersion_t;

//! Create the OrionClevisVersion packet
void encodeOrionClevisVersionPacketStructure(void* pkt, const OrionClevisVersion_t* user);

//! Decode the OrionClevisVersion packet
int decodeOrionClevisVersionPacketStructure(const void* pkt, OrionClevisVersion_t* user);

//! return the packet ID for the OrionClevisVersion packet
#define getOrionClevisVersionPacketID() (ORION_PKT_CLEVIS_VERSION)

//! return the minimum encoded length for the OrionClevisVersion packet
#define getOrionClevisVersionMinDataLength() (32)

//! return the maximum encoded length for the OrionClevisVersion packet
#define getOrionClevisVersionMaxDataLength() (36)

/*!
 * Software version for the crown board in the Orion gimbal.
 */
typedef struct
{
    char     Version[16];    //!< Version of the crown board software
    char     PartNumber[16]; //!< Hardware details of the crown board
    uint32_t OnTime;         //!< Board on time in minutes
}OrionCrownVersion_t;

//! Create the OrionCrownVersion packet
void encodeOrionCrownVersionPacketStructure(void* pkt, const OrionCrownVersion_t* user);

//! Decode the OrionCrownVersion packet
int decodeOrionCrownVersionPacketStructure(const void* pkt, OrionCrownVersion_t* user);

//! return the packet ID for the OrionCrownVersion packet
#define getOrionCrownVersionPacketID() (ORION_PKT_CROWN_VERSION)

//! return the minimum encoded length for the OrionCrownVersion packet
#define getOrionCrownVersionMinDataLength() (32)

//! return the maximum encoded length for the OrionCrownVersion packet
#define getOrionCrownVersionMaxDataLength() (36)

/*!
 * Software version for the payload board in the Orion gimbal.
 */
typedef struct
{
    char     Version[24];    //!< Version of the payload board software
    char     PartNumber[16]; //!< Hardware details of the payload board
    uint32_t OnTime;         //!< Board on time in minutes
}OrionPayloadVersion_t;

//! Create the OrionPayloadVersion packet
void encodeOrionPayloadVersionPacketStructure(void* pkt, const OrionPayloadVersion_t* user);

//! Decode the OrionPayloadVersion packet
int decodeOrionPayloadVersionPacketStructure(const void* pkt, OrionPayloadVersion_t* user);

//! return the packet ID for the OrionPayloadVersion packet
#define getOrionPayloadVersionPacketID() (ORION_PKT_PAYLOAD_VERSION)

//! return the minimum encoded length for the OrionPayloadVersion packet
#define getOrionPayloadVersionMinDataLength() (40)

//! return the maximum encoded length for the OrionPayloadVersion packet
#define getOrionPayloadVersionMaxDataLength() (44)

/*!
 * Software version for the tracker board in the Orion Gimbal (if applicable)
 */
typedef struct
{
    char     Version[16];    //!< Version of the tracker board software
    char     PartNumber[16]; //!< Hardware details of the tracker board
    uint32_t AppBits;        //!< Tracker application license bitfield
}OrionTrackerVersion_t;

//! Create the OrionTrackerVersion packet
void encodeOrionTrackerVersionPacketStructure(void* pkt, const OrionTrackerVersion_t* user);

//! Decode the OrionTrackerVersion packet
int decodeOrionTrackerVersionPacketStructure(const void* pkt, OrionTrackerVersion_t* user);

//! Create the OrionTrackerVersion packet
void encodeOrionTrackerVersionPacket(void* pkt, const char Version[16], const char PartNumber[16], uint32_t AppBits);

//! Decode the OrionTrackerVersion packet
int decodeOrionTrackerVersionPacket(const void* pkt, char Version[16], char PartNumber[16], uint32_t* AppBits);

//! return the packet ID for the OrionTrackerVersion packet
#define getOrionTrackerVersionPacketID() (ORION_PKT_TRACKER_VERSION)

//! return the minimum encoded length for the OrionTrackerVersion packet
#define getOrionTrackerVersionMinDataLength() (32)

//! return the maximum encoded length for the OrionTrackerVersion packet
#define getOrionTrackerVersionMaxDataLength() (36)

/*!
 * Software version for the retract board in the Retract Unit (if applicable)
 */
typedef struct
{
    char Version[16]; //!< Version of the retract board software
}OrionRetractVersion_t;

//! Create the OrionRetractVersion packet
void encodeOrionRetractVersionPacketStructure(void* pkt, const OrionRetractVersion_t* user);

//! Decode the OrionRetractVersion packet
int decodeOrionRetractVersionPacketStructure(const void* pkt, OrionRetractVersion_t* user);

//! Create the OrionRetractVersion packet
void encodeOrionRetractVersionPacket(void* pkt, const char Version[16]);

//! Decode the OrionRetractVersion packet
int decodeOrionRetractVersionPacket(const void* pkt, char Version[16]);

//! return the packet ID for the OrionRetractVersion packet
#define getOrionRetractVersionPacketID() (ORION_PKT_RETRACT_VERSION)

//! return the minimum encoded length for the OrionRetractVersion packet
#define getOrionRetractVersionMinDataLength() (16)

//! return the maximum encoded length for the OrionRetractVersion packet
#define getOrionRetractVersionMaxDataLength() (16)

/*!
 * Software version for the retract board in the Retract Unit (if applicable)
 */
typedef struct
{
    char Version[16]; //!< Version of the retract board software
}OrionLensCtlVersion_t;

//! Create the OrionLensCtlVersion packet
void encodeOrionLensCtlVersionPacketStructure(void* pkt, const OrionLensCtlVersion_t* user);

//! Decode the OrionLensCtlVersion packet
int decodeOrionLensCtlVersionPacketStructure(const void* pkt, OrionLensCtlVersion_t* user);

//! Create the OrionLensCtlVersion packet
void encodeOrionLensCtlVersionPacket(void* pkt, const char Version[16]);

//! Decode the OrionLensCtlVersion packet
int decodeOrionLensCtlVersionPacket(const void* pkt, char Version[16]);

//! return the packet ID for the OrionLensCtlVersion packet
#define getOrionLensCtlVersionPacketID() (ORION_PKT_LENSCTL_VERSION)

//! return the minimum encoded length for the OrionLensCtlVersion packet
#define getOrionLensCtlVersionMinDataLength() (16)

//! return the maximum encoded length for the OrionLensCtlVersion packet
#define getOrionLensCtlVersionMaxDataLength() (16)

/*!
 * Information for a specific board in the gimbal.
 */
typedef struct
{
    uint32_t                boardSN;         //!< Serial number of this board
    uint32_t                assemblySN;      //!< Serial number of the whole assembly
    uint32_t                config;          //!< Configuration bits
    OrionBoardEnumeration_t boardEnum;       //!< Enumeration defining which board in the gimbal this data applies to
    Date_t                  manufactureDate; //!< Date the board was manufactured
    Date_t                  calibrationDate; //!< Date the board was calibrated
}OrionBoard_t;

//! Create the OrionBoard packet
void encodeOrionBoardPacketStructure(void* pkt, const OrionBoard_t* user);

//! Decode the OrionBoard packet
int decodeOrionBoardPacketStructure(const void* pkt, OrionBoard_t* user);

//! return the packet ID for the OrionBoard packet
#define getOrionBoardPacketID() (ORION_PKT_BOARD)

//! return the minimum encoded length for the OrionBoard packet
#define getOrionBoardMinDataLength() (20)

//! return the maximum encoded length for the OrionBoard packet
#define getOrionBoardMaxDataLength() (20)

/*!
 * Autopilot state data. The gimbal will use this information to limit certain
 * operations, for example some lasers will not fire unless the autopilot is
 * flying with sufficient altitude above ground.
 */
typedef struct
{
    uint8_t IsFlying; //!< Set to 1 if flying, otherwise 0
    uint8_t CommGood; //!< Set to 1 if AP comms are good, otherwise 0
    int16_t Agl;      //!< Altitude above ground level in meters. Invalid if less than zero
}OrionAutopilotData_t;

//! Create the OrionAutopilotData packet
void encodeOrionAutopilotDataPacketStructure(void* pkt, const OrionAutopilotData_t* user);

//! Decode the OrionAutopilotData packet
int decodeOrionAutopilotDataPacketStructure(const void* pkt, OrionAutopilotData_t* user);

//! return the packet ID for the OrionAutopilotData packet
#define getOrionAutopilotDataPacketID() (ORION_PKT_AUTOPILOT_DATA)

//! return the minimum encoded length for the OrionAutopilotData packet
#define getOrionAutopilotDataMinDataLength() (4)

//! return the maximum encoded length for the OrionAutopilotData packet
#define getOrionAutopilotDataMaxDataLength() (4)

/*!
 * Externally supplied heading information. Send this packet to supply a
 * correction to the heading of the inertial navigation system of the gimbal.
 * This packet will be echoed back to the user if INS logging is enabled.
 */
typedef struct
{
    float    extHeading;              //!< External true heading observation in radians from -pi to pi
    float    noise;                   //!< Sensor noise of the heading observation in radians. Send 0 to cause the INS to simply shift its heading. Otherwise the extHeading will be fed into the INS kalman filter with this sensor noise.
    unsigned headingInGimbalAxis : 1; //!< Set this if the provided heading is in gimbal native axis rather than the platform axis. This will cause the gimbal to rotate the heading reference as needed to the platform axis used by the INS. This will have no effect if the INS options do not specify a platform rotation.
    unsigned headingFromAlign : 1;    //!< Set this if the provided heading came from an align system.
    float    pitch;                   //!< Pitch angle in radians from -pi to pi of the vector used to compute heading.
}OrionExtHeadingData_t;

//! Create the OrionExtHeadingData packet
void encodeOrionExtHeadingDataPacket(void* pkt, float extHeading, float noise, unsigned headingInGimbalAxis, unsigned headingFromAlign, float pitch);

//! Decode the OrionExtHeadingData packet
int decodeOrionExtHeadingDataPacket(const void* pkt, float* extHeading, float* noise, unsigned* headingInGimbalAxis, unsigned* headingFromAlign, float* pitch);

//! return the packet ID for the OrionExtHeadingData packet
#define getOrionExtHeadingDataPacketID() (ORION_PKT_EXT_HEADING_DATA)

//! return the minimum encoded length for the OrionExtHeadingData packet
#define getOrionExtHeadingDataMinDataLength() (4)

//! return the maximum encoded length for the OrionExtHeadingData packet
#define getOrionExtHeadingDataMaxDataLength() (8)

/*!
 * Ranging information from the gimbal to its target. The gimbal will use this
 * information to compute the target location and populate that informtaion in
 * its telemetry output.
 */
typedef struct
{
    float          range;    //!< Range to target in meters
    uint16_t       maxAgeMs; //!< Maximum data age before expiration in milliseconds
    RangeDataSrc_t source;   //!< Source of range information
}OrionRangeData_t;

//! Create the OrionRangeData packet
void encodeOrionRangeDataPacket(void* pkt, float range, uint16_t maxAgeMs, RangeDataSrc_t source);

//! Decode the OrionRangeData packet
int decodeOrionRangeDataPacket(const void* pkt, float* range, uint16_t* maxAgeMs, RangeDataSrc_t* source);

//! return the packet ID for the OrionRangeData packet
#define getOrionRangeDataPacketID() (ORION_PKT_RANGE_DATA)

//! return the minimum encoded length for the OrionRangeData packet
#define getOrionRangeDataMinDataLength() (7)

//! return the maximum encoded length for the OrionRangeData packet
#define getOrionRangeDataMaxDataLength() (7)

#ifdef __cplusplus
}
#endif
#endif
